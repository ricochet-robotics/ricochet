/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload Server
autoload Array
autoload Timer
autoload Server::Boards
autoload Server::Clients

extend namespace Server {
    public namespace Games {
	public (&Game)[0]	games = {};

	&Game insert () {
	    return Array::append (&games, reference ((Game) {}));
	}

	void remove (&Game g) {
	    Array::remove (&games, &g);
	}
	
	public void iterate (void (&Game g) f) {
	    Array::iterate (&games, f);
	}
    
	public exception no_such_game (string name);
	public exception notactive (&Game g, &Client c);
	public exception notbidding (&Game g);
	public exception notlower (&Game g, &Client c, int bid);
	public exception toomanymoves (&Game g, &Client c);
	public exception blocked (&Game g, &Client c);
	
	public &Game find (string name) {
	    exception	found (&Game g);
	    try {
		iterate (void func (&Game g) {
		    if (g.name == name)
			raise found (&g);
		});
	    } catch found (&Game g) {
		return &g;
	    }
	    raise no_such_game (name);
	}

	bool exists (string name) {
	    exception	found (&Game g);
	    try {
		iterate (void func (&Game g) {
		    if (g.name == name)
			raise found (&g);
		});
	    } catch found (&Game g) {
		return true;
	    }
	    return false;
	}

	public void remove_client (&Game g, &Client c) {
	    if (g.active == (ClientRef.client) (&c))
		g.active = ClientRef.none;
	    Array::remove (&g.clients, &c);
	}

	public &Client add_client (&Game g, &Client c, bool playing) {
	    if (c.game != GameRef.none)
		remove_client (&c.game.game, &c);
	    c.game = (GameRef.game) (&g);
	    c.playing = playing;
	    c.score = 0;
	    c.bid = Bid.none;
	    Array::append (&g.clients, &c);
	    Clients::game_send (&g, "NOTICE %s %s %s\n", 
				playing ? "JOIN" : "WATCH",
				g.name, c.user.username);
	    return &c;
	}

	public void iterate_client (&Game g, void (&Client c) f) {
	    Array::iterate (&g.clients, f);
	}

	Target[*] random_targets () {
	    static Color[4]    colors = {
		Color.Red, Color.Yellow, Color.Green, Color.Blue
	    };
	    static Shape[4]    shapes = {
		Shape.Triangle, Shape.Square, Shape.Octagon, Shape.Circle
	    };
	    Target[17] t = { [i] = i < 16 ? 
		(Target) { 
		    color = colors[i // 4], 
		    shape = shapes[i % 4],
		    active = false
		} :
		(Target) {
		    color = Color.Whirl,
		    shape = Shape.Whirl,
		    active = false
		} };
	    Shuffle::shuffle (&t);
	    return t;
	}
	    
	void next_target (&Game g) {
	    Target  t = g.targets[0];
	    g.targets = (Target[dim(g.targets)-1]) { [i] = g.targets[i+1] };
	    g.history = (ObjectLoc[*]) {};
	    g.time = Time.none;
	    g.state = GameState.New;
	    Boards::set_target (&g.board, t.color, t.shape);

	    void reset_client (&Client c) {
		c.bid = Bid.none;
	    }
	    iterate_client (&g, reset_client);
	    Clients::game_send (&g, "NOTICE TURN %C %S\n", t.color, t.shape);
	}

	public void next_turn (&Game g) {
	    next_target (&g);
	}

	public &Game new (string suggestion) {
	    string name;
	    for (int n = 0; 
		 exists (name = (n != 0) ? 
			 sprintf ("%s-%d", suggestion, n) : suggestion);
		 n++)
		 ;
	    &Game g = insert ();
	    g.name = name;
	    g.clients = ((&Client)[*]) {};
	    g.board = Boards::random_board ();
	    g.targets = random_targets ();
	    g.active = ClientRef.none;
	    g.timer_serial = 0;
	    next_target (&g);
	    return &g;
	}

	public ClientRef active_client (&Game g) {
	    return g.active;
	}

	void assert_active (&Game g, &Client c) {
	    if (g.active != (ClientRef.client) (&c))
		raise notactive (&g, &c);
	}
	
	void undo_move (&Game g)
	{
	    ObjectLoc ol = Array::pop (&g.history);
	    Boards::position_robot (&g.board, ol.object.robot.robot.color,
				    ol.x, ol.y);
	}
	
	public void undo (&Game g, &Client c) {
	    assert_active (&g, &c);
	    if (dim (g.history) > 0)
	    {
		undo_move (&g);
		Clients::game_send (&g, "NOTICE UNDO\n");
	    }
	}

	public void reset (&Game g, &Client c) {
	    assert_active (&g, &c);
	    while (dim (g.history) > 0)
		undo (&g, &c);
	    Clients::game_send (&g, "NOTICE RESEt\n");
	}

	ClientRef lowest_bidder (&Game g) {
	    Bid		min = Bid.none;
	    ClientRef	min_client = ClientRef.none;
	    void lower_bid (&Client c) {
		union switch (c.bid) {
		case none:
		    break;
		case number n:
		    if (min == Bid.none || min.number > n)
		    {
			min = (Bid.number) n;
			min_client = (ClientRef.client) (&c);
		    }
		    break;
		}
	    }
	    iterate_client (&g, lower_bid);
	    return min_client;
	}

	void set_active (&Game g) {
	    g.active = lowest_bidder (&g);

	    union switch (g.active) {
	    case none:
		break;
	    case client c:
		Clients::game_send (&g, "NOTICE ACTIVE %s %d\n",
				    c.user.username, c.bid.number);
		break;
	    }
	}

	void set_state (&Game g, GameState state) {
	    g.state = state;
	    Clients::game_send (&g, "NOTICE GAMESTATE %G\n", state);
	    switch (state) {
	    case GameState.Bidding:
		int timer_serial = ++g.timer_serial;
		
		bool validate () {
		    if (g.state != GameState.Bidding || 
			g.timer_serial != timer_serial)
			    return false;
		    return true;
		}
		
		void notify (int remain) {
		    Clients::game_send (&g, "NOTICE TIMER %d\n",
					remain);
		}

		void expire () {
		    set_state (&g, GameState.Showing);
		}

		Timer::start (60, 10, lock, unlock, validate, notify, expire);
		break;
	    case GameState.Showing:
		set_active (&g);
		break;
	    }
	}

	public void bid (&Game g, &Client c, int number) {
	    switch (g.state) {
	    case GameState.New:
		set_state (&g, GameState.Bidding);
	    case GameState.Bidding:
		break;
	    case GameState.Showing:
	    case GameState.Solved:
		raise notbidding (&g);
		break;
	    }
	    if (c.bid != Bid.none && c.bid.number <= number)
		raise notlower (&g, &c, number);
	    c.bid = (Bid.number) number;
	    Clients::game_send (&g, "NOTICE BID %s %d\n", c.user.username, number);
	}
	
	public int count (&Game g) {
	    return dim (g.history);
	}

	public void move (&Game g, &Client c, Color color, Direction dir) {
	    assert_active (&g, &c);
	    if (count (&g) >= c.bid.number)
		raise toomanymoves (&g, &c);
	    ObjectLoc	src = Boards::find_robot (&g.board, color);
	    ObjectLoc	dst = Boards::move_robot (&g.board, color, dir);
	    if (src == dst)
		raise blocked (&g, &c);
	    Array::push (&g.history, src);
	    Boards::position_robot (&g.board, color, dst.x, dst.y);
	    Clients::game_send (&g, "NOTICE MOVE %d %C %D\n",
				Games::count (&g), color, dir);
	    if (Boards::solved (&g.board))
		set_state (&g, GameState.Solved);
	}

	public bool solved (&Game g) {
	    return Boards::solved (&g.board);
	}
    }
}
