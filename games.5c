/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload Server
autoload Array
autoload Timer
autoload Server::Boards
autoload Server::Clients

extend namespace Server {
    public namespace Games {
	public (&Game)[0]	games = {};

	&Game insert () {
	    return Array::append (&games, reference ((Game) {}));
	}

	void remove (&Game g) {
	    Array::remove (&games, &g);
	}
	
	/* iterate over the available games */
	public void iterate (void (&Game g) f) {
	    Array::iterate (&games, f);
	}
    
	public exception no_such_game (string name);
	
	/* find a game by name */
	public &Game find (string name) {
	    exception	found (&Game g);
	    try {
		iterate (void func (&Game g) {
		    if (g.name == name)
			raise found (&g);
		});
	    } catch found (&Game g) {
		return &g;
	    }
	    raise no_such_game (name);
	}

	bool exists (string name) {
	    exception	found (&Game g);
	    try {
		iterate (void func (&Game g) {
		    if (g.name == name)
			raise found (&g);
		});
	    } catch found (&Game g) {
		return true;
	    }
	    return false;
	}

	/* list clients associated with a game */
	public void iterate_client (&Game g, void (&Client c) f, 
				    bool playing, bool watching) {
	    void pick (&Client c) {
		if ((playing && c.playing) || (watching && !c.playing))
		    f (&c);
	    }
	    Array::iterate (&g.clients, pick);
	}

	public void game_send (&Game g, string fmt, poly args...) {
	    void	message_client (&Client o) {
		Clients::client_send (&o, fmt, args...);
	    }
	    iterate_client (&g, message_client, true, true);
	}

	bool any_bids (&Game g) {
	    bool    any = false;
	    void bid_set (&Client c) {
		if (c.bid != Bid.none)
		    any = true;
	    }
	    iterate_client (&g, bid_set, true, false);
	    return any;
	}

	ClientRef lowest_bidder (&Game g) {
	    Bid		min = Bid.none;
	    ClientRef	min_client = ClientRef.none;
	    void lower_bid (&Client c) {
		union switch (c.bid) {
		case none:
		    break;
		case number n:
		    if (min == Bid.none || min.number > n)
		    {
			min = (Bid.number) n;
			min_client = (ClientRef.client) (&c);
		    }
		    break;
		}
	    }
	    iterate_client (&g, lower_bid, true, false);
	    return min_client;
	}

	void set_active (&Game g) {
	    ClientRef	active = lowest_bidder (&g);

	    if (active != g.active) {
		g.active = active;
		union switch (active) {
		case none:
		    break;
		case client c:
		    game_send (&g, "NOTICE ACTIVE %s %d\n",
			       c.user.username, c.bid.number);
		    break;
		}
	    }
	}

	void set_state (&Game g, GameState state) {
	    g.state = state;
	    game_send (&g, "NOTICE GAMESTATE %G\n", state);
	    switch (state) {
	    case GameState.Bidding:
		int timer_serial = ++g.timer_serial;
		
		bool validate () {
		    if (g.state != GameState.Bidding || 
			g.timer_serial != timer_serial)
			    return false;
		    return true;
		}
		
		void notify (int remain) {
		    game_send (&g, "NOTICE TIMER %d\n", remain);
		}

		void expire () {
		    set_state (&g, GameState.Showing);
		}

		Timer::start (60, 10, lock, unlock, validate, notify, expire);
		break;
	    case GameState.Showing:
		set_active (&g);
		break;
	    }
	}

	/* remove a client from any game */
	public void remove_client (&Client c) {
	    if (c.game == GameRef.none)
		return;
	    &Game g = &c.game.game;
	    Array::remove (&g.clients, &c);
	    game_send (&g, "NOTICE PART %s\n", c.user.username);
	    /* correct the state if necessary */
	    switch (g.state) {
	    case GameState.New:
		break;
	    case GameState.Bidding:
		if (!any_bids (&g))
		    set_state (&g, GameState.New);
		break;
	    case GameState.Showing:
		set_active (&g);
		if (g.active == ClientRef.none)
		    set_state (&g, GameState.New);
		break;
	    case GameState.Solved:
		break;
	    }
	}

	/* add a client to a game */
	public &Client add_client (&Game g, &Client c, bool playing) {
	    remove_client (&c);
	    c.game = (GameRef.game) (&g);
	    c.playing = playing;
	    c.score = 0;
	    c.bid = Bid.none;
	    Array::append (&g.clients, &c);
	    game_send (&g, "NOTICE %s %s\n", 
		       playing ? "JOIN" : "WATCH",
		       c.user.username);
	    return &c;
	}

	/* select the next target */
	void next_target (&Game g) {
	    /* score */
	    if (g.active != ClientRef.none && Boards::solved (&g.board))
		g.active.client.score++;

	    Target  t = g.targets[0];
	    g.targets = (Target[dim(g.targets)-1]) { [i] = g.targets[i+1] };
	    g.history = (ObjectLoc[*]) {};
	    g.time = Time.none;
	    g.state = GameState.New;
	    Boards::set_target (&g.board, t.color, t.shape);

	    void reset_client (&Client c) {
		c.bid = Bid.none;
	    }
	    iterate_client (&g, reset_client, true, false);
	    game_send (&g, "NOTICE TURN %C %S\n", t.color, t.shape);
	}

	public void next_turn (&Game g) {
	    next_target (&g);
	}

	Target[*] random_targets () {
	    static Color[4]    colors = {
		Color.Red, Color.Yellow, Color.Green, Color.Blue
	    };
	    static Shape[4]    shapes = {
		Shape.Triangle, Shape.Square, Shape.Octagon, Shape.Circle
	    };
	    Target[17] t = { [i] = i < 16 ? 
		(Target) { 
		    color = colors[i // 4], 
		    shape = shapes[i % 4],
		    active = false
		} :
		(Target) {
		    color = Color.Whirl,
		    shape = Shape.Whirl,
		    active = false
		} };
	    Shuffle::shuffle (&t);
	    return t;
	}
	    
	public &Game new (string suggestion) {
	    string name;
	    for (int n = 0; 
		 exists (name = (n != 0) ? 
			 sprintf ("%s-%d", suggestion, n) : suggestion);
		 n++)
		 ;
	    &Game g = insert ();
	    g.name = name;
	    g.clients = ((&Client)[*]) {};
	    g.board = Boards::random_board ();
	    g.targets = random_targets ();
	    g.active = ClientRef.none;
	    g.timer_serial = 0;
	    next_target (&g);
	    Clients::server_send ("NOTICE NEW %s\n", g.name);
	    return &g;
	}

	public ClientRef active_client (&Game g) {
	    return g.active;
	}

	void assert_active (&Game g, &Client c) {
	    if (g.active != (ClientRef.client) (&c))
		raise error (Error.NOTACTIVE);
	}
	
	void undo_move (&Game g)
	{
	    ObjectLoc ol = Array::pop (&g.history);
	    Boards::position_robot (&g.board, ol.object.robot.robot.color,
				    ol.x, ol.y);
	}
	
	public void undo (&Game g, &Client c) {
	    assert_active (&g, &c);
	    if (dim (g.history) > 0)
	    {
		undo_move (&g);
		game_send (&g, "NOTICE UNDO\n");
	    }
	}

	public void reset (&Game g, &Client c) {
	    assert_active (&g, &c);
	    while (dim (g.history) > 0)
		undo (&g, &c);
	    game_send (&g, "NOTICE RESET\n");
	}

	public void bid (&Game g, &Client c, int number) {
	    switch (g.state) {
	    case GameState.New:
		set_state (&g, GameState.Bidding);
	    case GameState.Bidding:
		break;
	    case GameState.Showing:
	    case GameState.Solved:
		raise error (Error.NOTBIDDING);
		break;
	    }
	    /*
	    if (c.bid != Bid.none && c.bid.number <= number)
		raise error (Error.NOTLOWER);
	     */
	    c.bid = (Bid.number) number;
	    game_send (&g, "NOTICE BID %s %d\n", c.user.username, number);
	}

	public void revoke (&Game g, &Client c) {
	    if (c.bid == Bid.none)
		raise error (Error.NOBID);
	    c.bid = Bid.none;
	    if (!any_bids(&g))
		set_state (&g, GameState.New);
	}
	
	public int count (&Game g) {
	    return dim (g.history);
	}

	public void move (&Game g, &Client c, Color color, Direction dir) {
	    assert_active (&g, &c);
	    if (count (&g) >= c.bid.number)
		raise error (Error.TOOMANYMOVES);
	    ObjectLoc	src = Boards::find_robot (&g.board, color);
	    ObjectLoc	dst = Boards::move_robot (&g.board, color, dir);
	    if (src == dst)
		raise error (Error.BLOCKED);
	    Array::push (&g.history, src);
	    Boards::position_robot (&g.board, color, dst.x, dst.y);
	    game_send (&g, "NOTICE MOVE %d %C %D\n", count (&g), color, dir);
	    if (Boards::solved (&g.board))
		set_state (&g, GameState.Solved);
	}

	public bool solved (&Game g) {
	    return Boards::solved (&g.board);
	}
    }
}
