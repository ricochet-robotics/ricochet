/*
 * Copyright Â© 2012 Keith Packard <keithp@keithp.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

autoload Nichrome;
autoload Nichrome::Scrollbar;

extend namespace Nichrome {

	public namespace Edit {

		import Cairo;

		typedef struct {
			int			pos;
			int			len;
		} line_t;

		public typedef widget_t + struct {
			string			text;
			string			font;
			rgba_color_t		color;
			font_extents_t		font_extents;
			int			top;
			int			lines;
			real			old_width;
			bool			dirty;
			line_t[*]		layout;
			*Scrollbar::scrollbar_t	scrollbar;
		} edit_t;

		/* just after the previous newline */
		int bol(&edit_t edit, int pos) {
			for (; --pos >= 0;)
				if (edit.text[pos] == '\n')
					return pos + 1;
			return 0;
		}

		/* on the next newline */
		int eol (&edit_t edit, int pos) {
			for (; pos < String::length(edit.text); pos++)
				if (edit.text[pos] == '\n')
					return pos;
			return pos;
		}

		/* column number of 'pos' */
		int column (&edit_t e, int pos) {
			return pos - bol(&e, pos);
		}

		/* basic text motion */
		int left(&edit_t edit, int pos) {
			if (pos > 0)
				return pos - 1;
			return pos;
		}

		int right(&edit_t edit, int pos) {
			if (pos < String::length(edit.text))
				return pos + 1;
			return pos;
		}

		int up(&edit_t edit, int pos) {
			int	e = bol(&edit, pos) - 1;
			if (e >= 0) {
				int prev = bol(&edit, e);
				return min(prev + column(&edit, pos), e);
			}
			return pos;
		}

		int down(&edit_t edit, int pos) {
			int	next = eol(&edit, pos) + 1;

			if (next <= String::length(edit.text))
				return min(eol(&edit, next),
					   next + column(&edit, pos));
			return pos;
		}

		/* painted width of specified subset of text */
		real width(cairo_t cr, &edit_t edit, int start, int end) {
			text_extents_t	t = text_extents(cr, String::substr(edit.text, start,
									    end-start));
			return t.x_advance;
		}

		void set_scroll(&edit_t edit) {
			if (is_uninit(&edit.scrollbar))
				return;

			real	top = edit.top / dim(edit.layout);
			real	bottom = min((edit.top + edit.lines) / dim(edit.layout), 1);
			Scrollbar::set(edit.scrollbar,
				       top, bottom - top);
		}

		void prep(cairo_t cr, &edit_t edit) {
			set_font(cr, edit.font);
			edit.font_extents = font_extents(cr);
			if (edit.old_width != edit.geometry.width) {
				edit.dirty = true;
				edit.old_width = edit.geometry.width;
			}
			if (edit.dirty) {
				edit.layout = (line_t[...]) {};

				int	pos = 0;
				int	l = 0;
				do {
					int	e = eol(&edit, pos);
					while (e > pos + 1 && width(cr, &edit, pos, e) > edit.geometry.width)
						e--;
					edit.layout[l] = (line_t) { .pos = pos,
								    .len = e - pos };
					pos = e;
					if (pos < String::length(edit.text) && edit.text[pos] == '\n')
						pos++;
					l++;
				} while (pos < String::length(edit.text));

				edit.dirty = false;
			}
			edit.top = min(edit.top, dim(edit.layout) - 1);
			edit.lines = max (1, floor(edit.geometry.height / edit.font_extents.height));
			set_scroll(&edit);
		}

		void paint (cairo_t cr, &edit_t edit) {
			for (int i = edit.top; i < dim(edit.layout) && i < edit.top + edit.lines; i++) {
				move_to (cr, 0, (i - edit.top) * edit.font_extents.height + edit.font_extents.ascent);
				set_source_rgba (cr, edit.color.red, edit.color.green,
						 edit.color.blue, edit.color.alpha);
				show_text(cr, String::substr(edit.text, edit.layout[i].pos, edit.layout[i].len));
			}
		}

		public void insert(&edit_t edit, int pos, string s) {
			edit.text = String::substr(edit.text, 0, pos) +
				s + String::substr(edit.text, pos, String::length(edit.text) - pos);
			edit.dirty = true;
			Widget::redraw(&edit);
		}

		public void delete(&edit_t edit, int pos, int n) {
			n = min (n, String::length(edit.text) - pos);

			edit.text = String::substr(edit.text, 0, pos) +
				String::substr(edit.text, pos + n, String::length(edit.text) - (pos + n));
			edit.dirty = true;
			Widget::redraw(&edit);
		}

		public bool scroll_up(&edit_t edit) {
			if (edit.top > 0) {
				edit.top--;
				Widget::redraw(&edit);
				return true;
			}
			return false;
		}

		public bool scroll_down(&edit_t edit) {
			if (edit.top < dim(edit.layout) - edit.lines) {
				edit.top++;
				Widget::redraw(&edit);
				return true;
			}
			return false;
		}

		void draw(cairo_t cr, &edit_t edit) {
			prep(cr, &edit);
			paint(cr, &edit);
		}

		void natural(cairo_t cr, &edit_t edit) {
			prep(cr, &edit);
			rectangle(cr, 0, 0, 200, 200);
		}

		void outline(cairo_t cr, &edit_t edit) {
			natural(cr, &edit);
		}

		void print(&edit_t edit, int indent) {
			do_indent(indent);
			printf("edit %s\n", edit.text);
		}

		
		public void init (&edit_t edit, &nichrome_t nichrome) {
			Widget::init(&nichrome, &edit);
			edit.text = "";
			edit.dirty = true;
			edit.old_width = 0;
			edit.draw = draw;
			edit.top = 0;
			edit.outline = outline;
			edit.natural = natural;
			edit.font = Widget::default_font;
			edit.color = (rgba_color_t) {
				red = 0, green = 0, blue = 0, alpha = 1
			};
			edit.print = print;
		}

		public *Scrollbar::scrollbar_t scrollbar(&edit_t edit) {
			if (is_uninit(&edit.scrollbar)) {
				void scrollbar_callback(&widget_t scroll, Scrollbar::action_t action) {
					printf ("action %v\n", action);
					union switch (action) {
					case drag pos:
						edit.top = floor (pos * dim(edit.layout) + 0.5);
						set_scroll(&edit);
						Widget::redraw(&edit);
						break;
					case pos pos:
						break;
					default:
						break;
					}
				}
				edit.scrollbar = Scrollbar::new(&edit.nichrome,
								 Scrollbar::dir_t.vertical,
								 scrollbar_callback);
			}
			return edit.scrollbar;
		}

		public *widget_t new (&nichrome_t nichrome) {
			*edit_t	edit = &(edit_t) {};

			init(edit, &nichrome);
			return edit;
		}
	}
}
