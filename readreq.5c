/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload RR::Lex
autoload Ctype

extend namespace Server {
    public namespace Readreq {
	public exception invalid_request (string w);
	public exception request_closed ();

	import RR;
	import Lex;

	string function upper (string s)
	{
	    string  r = "";
	    for (int i = 0; i < String::length (s); i++)
		r = r + String::new (Ctype::toupper (s[i]));
	    return r;
	}

	public Request read (file f) {
	    struct {} packet;
	    void username_ (&struct { string username; } packet) {
		packet.username = word (f); 
	    }
	    void game_ (&struct { string game; } packet) {
		packet.game = word (f); 
	    }
	    void number_ (&struct { int number; } packet) {
		packet.number = number (f);
	    }
	    void color_ (&struct { Color color; } packet) {
		packet.color = color (f);
	    }
	    void shape_ (&struct { Shape shape; } packet) {
		packet.shape = shape (f);
	    }
	    void direction_ (&struct { Direction direction; } packet) {
		packet.direction = direction (f);
	    }
	    void text_ (&struct { string text; } packet) {
		packet.text = word (f);
	    }
	    switch (string w = upper (firstword (f))) {
	    case "HELO":
		packet = (struct { string username; }) {};
		username_ (&packet);
		return (Request.HELO) packet;
	    case "WHO":
		return Request.WHO;
	    case "GAMES":
		return Request.GAMES;
	    case "USERS":
		packet = (struct { string game; }) {};
		game_ (&packet);
		return (Request.USERS) packet;
	    case "NEW":
		packet = (struct { string game; }) {};
		game_ (&packet);
		return (Request.NEW) packet;
	    case "JOIN":
		packet = (struct { string game; }) {};
		game_ (&packet);
		return (Request.JOIN) packet;
	    case "WATCH":
		packet = (struct { string game; }) {};
		game_ (&packet);
		return (Request.WATCH) packet;
	    case "SHOW":
		return Request.SHOW;
	    case "BID":
		packet = (struct { int number; }) {};
		number_ (&packet);
		return (Request.BID) packet;
	    case "MOVE":
		packet = (struct { Color color; Direction direction; }) {};
		color_ (&packet);
		direction_ (&packet);
		return (Request.MOVE) packet;
	    case "UNDO":
		return Request.UNDO;
	    case "RESET":
		return Request.RESET;
	    case "TURN":
		return Request.TURN;
	    case "PASS":
		return Request.PASS;
	    case "MESSAGE":
		packet = (struct { string text; }) {};
		text_ (&packet);
		return (Request.MESSAGE) packet;
	    case "QUIT":
		return Request.QUIT;
	    case "":
		raise request_closed ();
	    default:
		skipline (f);
		raise invalid_request (w);
	    }
	}
    }
}
