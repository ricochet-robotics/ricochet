/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

namespace Connection {
    Client[0]    clients;

    public void iterate (void (&Client c) f) {
	for (int i = 0; i < dim (clients); i++)
	    f (&clients[i]);
    }

    public exception no_such_client (file f);
    
    public &Client select (file f) {
	exception found (&Client c);
	try {
	    void pick (&Client c) {
		if (c.f == f)
		    raise found (&c);
	    }
	    iterate (pick);
	} catch found (&Client c) {
	    return &c;
	}
        raise no_such_client (f);
    }

    public &Client new (file f) {
	clients = (Client[dim(clients)+1]) { 
	    [i] = i < dim(clients) ? 
	    clients[i] : 
	    (Client) { f = f, user = User.none, game = GameRef.none }
	};
	return &clients[dim(clients)-1];
    }

    public void dispose (&Client c) {
	bool found = false;
	
	clients = (Client[dim(clients)-1]) { 
	    [i] = found ? clients[i+1] : (&clients[i] == &c ? 
					  (found=true, clients[i+1]) :
					  clients[i])
	};
    }

    public void print (&Client c) {
	printf ("%v\n", c);
    }

}

namespace Request {
    public exception invalid_request (string w);
    public RRRequest read (file f) {
	switch (string w = RRLex::word (f)) {
	case "HELO":
	    return (RRRequest.HELO) (struct { string username; }) {
		username = RRLex::rest (f)
	    };
	case "WHO":
	    return RRRequest.WHO;
	case "GAMES":
	    return RRRequest.GAMES;
	case "USERS":
	    return (RRRequest.USERS) (struct { string game; }) {
		game = RRLex::rest (f)
	    };
	default:
	    raise invalid_request (w);
	}
    }
}
