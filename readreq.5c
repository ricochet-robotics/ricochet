/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload RR::Lex
autoload Ctype
autoload Server

extend namespace Server {
    public namespace Readreq {
	public exception invalid_request (string w);
	public exception request_closed ();

	import RR;
	import Lex;

	string function upper (string s)
	{
	    string  r = "";
	    for (int i = 0; i < String::length (s); i++)
		r = r + String::new (Ctype::toupper (s[i]));
	    return r;
	}

	Request read_unlocked (file f) {
	    struct {} packet;
	    void username_ (&struct { string username; } packet) {
		packet.username = word (f); 
	    }
	    void game_ (&struct { string game; } packet) {
		packet.game = word (f); 
	    }
	    void number_ (&struct { int number; } packet) {
		packet.number = number (f);
	    }
	    void color_ (&struct { Color color; } packet) {
		packet.color = color (f);
	    }
	    void shape_ (&struct { Shape shape; } packet) {
		packet.shape = shape (f);
	    }
	    void direction_ (&struct { Direction direction; } packet) {
		packet.direction = direction (f);
	    }
	    void text_ (&struct { string text; } packet) {
		packet.text = word (f);
	    }
	    Request req;
	    switch (string w = upper (firstword (f))) {
	    case "HELO":
		packet = (struct { string username; }) {};
		username_ (&packet);
		req = (Request.HELO) packet;
		break;
	    case "WHO":
		req = Request.WHO;
		break;
	    case "GAMES":
		req = Request.GAMES;
		break;
	    case "USERS":
		packet = (struct { string game; }) {};
		game_ (&packet);
		req = (Request.USERS) packet;
		break;
	    case "NEW":
		packet = (struct { string game; }) {};
		game_ (&packet);
		req = (Request.NEW) packet;
		break;
	    case "JOIN":
		packet = (struct { string game; }) {};
		game_ (&packet);
		req = (Request.JOIN) packet;
		break;
	    case "WATCH":
		packet = (struct { string game; }) {};
		game_ (&packet);
		req = (Request.WATCH) packet;
		break;
	    case "SHOW":
		req = Request.SHOW;
		break;
	    case "BID":
		packet = (struct { int number; }) {};
		number_ (&packet);
		req = (Request.BID) packet;
		break;
	    case "MOVE":
		packet = (struct { Color color; Direction direction; }) {};
		color_ (&packet);
		direction_ (&packet);
		req = (Request.MOVE) packet;
		break;
	    case "UNDO":
		req = Request.UNDO;
		break;
	    case "RESET":
		req = Request.RESET;
		break;
	    case "TURN":
		req = Request.TURN;
		break;
	    case "PASS":
		req = Request.PASS;
		break;
	    case "MESSAGE":
		packet = (struct { string text; }) {};
		text_ (&packet);
		req = (Request.MESSAGE) packet;
		break;
	    case "QUIT":
		req = Request.QUIT;
		break;
	    case "":
		raise request_closed ();
	    default:
		raise invalid_request (w);
	    }
	    if (!eol (f))
		raise syntax ();
	    return req;
	}

	public Request read (file f) {
	    twixt (unlock (); lock ())
		twixt (true; skipline (f))
		    return read_unlocked (f);
	    raise notreached ();
	}
    }
}
