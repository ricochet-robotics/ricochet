/*
 * Copyright © 2012 Keith Packard <keithp@keithp.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; version 2 of the License.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
 */

autoload Nichrome;
autoload RR;
autoload Client;
autoload Client::Draw;
autoload Mutex;

extend namespace Nichrome {

	public namespace RRboard {

		import Client;
		import RR;

		public int	board_width = RR::Width * Draw::cell_width;
		public int	board_height = RR::Height * Draw::cell_height;

		public typedef widget_t + struct {
			RR::Board		board;
			Mutex::mutex		timer_mutex;
			real			time;
			thread			timer;
			RR::RobotOrNone		active_robot;
			void (RR::Color color,
			      RR::Direction direction) move_callback;
			void () 		undo_callback;
			void (string key)	key_callback;
			int			button_x, button_y;
		} rrboard_widget_t;

		typedef struct {
			real	xoff, yoff;
			real	xscale, yscale;
		} transform_t;

		transform_t transform(&rrboard_widget_t widget) {
			real	dim = min (widget.geometry.width, widget.geometry.height);
			return (transform_t) {
				.xscale = dim / board_width,
				.yscale = dim / board_height,
				.xoff = (widget.geometry.width - dim) / 2,
				.yoff = (widget.geometry.height - dim) / 2
				};
		}

		void draw_clock (cairo_t cr, &rrboard_widget_t widget) {
			save (cr);
			new_path (cr);
			move_to (cr,
				 board_width / 2,
				 board_height / 2);
			arc (cr,
			     board_width / 2,
			     board_height / 2,
			     0.9 * Draw::cell_width,
			     - π / 2,
			     2 * π * (60.0 - widget.time) / 60.0 - π/2);
			close_path (cr);
			set_source_rgba (cr, 0.0, 0.0, 0.0, 0.5);
			fill (cr);

			restore (cr);
		}

		void run_timer (&rrboard_widget_t widget) {
			twixt(Mutex::acquire(widget.timer_mutex); Mutex::release(widget.timer_mutex)) {
				real	start = millis() / 1000;
				real	end = start + widget.time;

				while (widget.time >= 0) {
					real delay = 1;

					if (delay > widget.time)
						delay = widget.time;
					twixt(Mutex::release(widget.timer_mutex);
					      Mutex::acquire(widget.timer_mutex)) {
						sleep(floor (delay * 1000));
						Widget::redraw(&widget);
					}
					widget.time = end - millis() / 1000;
				}
				make_uninit(&widget.timer);
			}
		}

		void start_timer (&rrboard_widget_t widget) {
			twixt(Mutex::acquire(widget.timer_mutex); Mutex::release(widget.timer_mutex)) {
				if (is_uninit(&widget.timer)) {
					widget.timer = fork run_timer(&widget);
				}
			}
		}

		protected void set_timer (&rrboard_widget_t widget, real time) {
			widget.time = time;
			start_timer(&widget);
		}

		protected void stop_timer (&rrboard_widget_t widget) {
			widget.time = -1;
			twixt(Mutex::acquire(widget.timer_mutex); Mutex::release(widget.timer_mutex)) {
				if (!is_uninit(&widget.timer)) {
					Thread::kill(widget.timer);
					make_uninit(&widget.timer);
				}
			}
		}

		void draw (cairo_t cr, &rrboard_widget_t widget) {
			transform_t	t = transform(&widget);

			save(cr);
			translate(cr, t.xoff, t.yoff);
			scale(cr, t.xscale, t.yscale);
			for (int y = 0; y < RR::Height; y++)
				for (int x = 0; x < RR::Width; x++) {
					Draw::background(cr, x, y, widget.board[x,y]);
					Draw::walls(cr, x, y, widget.board[x,y]);
					Draw::contents(cr, x, y, widget.board[x,y], widget.active_robot);
				}
			for (int y = RR::Height / 2 - 1; y < RR::Height/2 + 1; y++)
				for (int x = RR::Width / 2 - 1; x < RR::Width/2 + 1; x++) {
					Draw::background(cr, x, y, widget.board[x,y]);
					Draw::walls(cr, x, y, widget.board[x,y]);
				}
			Draw::target(cr, RR::Width / 2 - 1, RR::Height / 2 - 1,
				     RR::active_target(&widget.board));
			if (widget.time >= 0)
				draw_clock(cr, &widget);
			restore(cr);
		}

		void outline (cairo_t cr, &rrboard_widget_t widget) {
			rectangle(cr, 0, 0, widget.geometry.width, widget.geometry.height);
		}

		void natural (cairo_t cr, &rrboard_widget_t widget) {
			rectangle(cr, 0, 0, board_width, board_height);
		}

		void set_active_robot(&rrboard_widget_t widget, RR::Robot robot) {
			widget.active_robot = (RR::RobotOrNone.robot) robot;
			Widget::redraw(&widget);
		}
		
		void set_active (&rrboard_widget_t widget, string color) {
			try {
				set_active_robot(&widget, (RR::Robot) { .color = RR::color(color) });
			} catch RR::rr_error(RR::Error error) {
			}
		}

		void move_active (&rrboard_widget_t widget, string dir) {
			try {
				RR::Direction direction = RR::direction(dir);
				union switch (widget.active_robot) {
				case robot r:
					widget.move_callback(r.color, direction);
					break;
				default:
				}
			} catch RR::rr_error(RR::Error error) {
			}
		}

		void undo(&rrboard_widget_t widget) {
			widget.undo_callback();
		}

		protected void key (&rrboard_widget_t widget, &key_event_t event) {

			if (event.type != key_type_t.press)
				return;

			switch (event.key) {
			case "r": case "R":
			case "g": case "G":
			case "b": case "B":
			case "y": case "Y":
				set_active (&widget, event.key);
				break;
			case " ": case "w":
				set_active (&widget, "whirl");
				break;
			case "Left": case "w": case "W":
				move_active(&widget, "west");
				break;
			case "Right": case "e": case "E":
				move_active(&widget, "east");
				break;
			case "Up": case "n": case "N":
				move_active(&widget, "north");
				break;
			case "Down": case "s": case "S":
				move_active(&widget, "south");
				break;
			case "BackSpace": case "u": case "U":
				undo(&widget);
				break;
			default:
				widget.key_callback(event.key);
				break;
			}
		}

		typedef struct { int x, y; } position_t;

		position_t find_robot (&rrboard_widget_t widget, RR::Robot robot) {
			for (int y = 0; y < RR::Height; y++)
				for (int x = 0; x < RR::Width; x++) {
					union switch (widget.board[x,y].robot) {
					case robot r:
						if (r.color == robot.color)
							return (position_t) { .x = x, .y = y };
						break;
					default:
					}
				}
			return (position_t) { .x = 0, .y = 0 };
		}

		protected void button (&rrboard_widget_t widget, &button_event_t event) {
			transform_t	t = transform(&widget);
			int		x = floor ((event.x - t.xoff) / t.xscale / Draw::cell_width);
			int		y = floor ((event.y - t.yoff) / t.yscale / Draw::cell_height);

			enum switch (event.type) {
			case press:
				RR::Object	object = widget.board[x,y];
				union switch (object.robot) {
				case robot r:
					set_active_robot(&widget, r);
					break;
				default:
				}
				break;
			case release:
				union switch (widget.active_robot) {
				case robot r:
					position_t	robot_pos = find_robot(&widget, r);
					int	dx = x - robot_pos.x;
					int	dy = y - robot_pos.y;

					if (abs (dx) > abs (dy)) {
						if (dx < 0)
							move_active(&widget, "west");
						else if (dx > 0)
							move_active(&widget, "east");
					} else {
						if (dy < 0)
							move_active(&widget, "north");
						else if (dy > 0)
							move_active(&widget, "south");
					}
					break;
				default:
					break;
				}
				break;
			default:
			}
		}

		public *rrboard_widget_t new(&nichrome_t nichrome,
					     void(RR::Color color, RR::Direction dir) move_callback,
					     void() undo_callback,
					     void(string key) key_callback) {
			rrboard_widget_t	widget;

			Widget::init(&nichrome, &widget);
			widget.draw = draw;
			widget.outline = outline;
			widget.natural = natural;
			widget.timer_mutex = Mutex::new();
			widget.time = -1;
			widget.key = key;
			widget.button = button;
			widget.active_robot = RobotOrNone.none;
			widget.move_callback = move_callback;
			widget.undo_callback = undo_callback;
			widget.key_callback = key_callback;
			widget.board = (RR::Board) { { { .robot = RobotOrNone.none,
							 .target = TargetOrNone.none,
							 .walls = { .left = false, .right = false,
								  .above = false, .below = false }
					} ... } ... };
			return &widget;
		}
	}
}
