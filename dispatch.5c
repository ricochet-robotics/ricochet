/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload RR
autoload RR::Send
autoload Server
autoload Server::Clients
autoload Server::Readreq
autoload Server::Show
autoload Server::Games

extend namespace Server {
    public namespace Dispatch {
	
	void client_locked (file f, &Client c) {
	    
	    exception	notactive ();
	    exception	notingame ();
	    exception	invalidname ();
	    exception	nonameset ();

	    void	respond (string fmt, poly args...) {
		Clients::client_send (&c, fmt, args...);
	    }

	    void assert_user ()
	    {
		if (c.user == User.none)
		    raise error (Error.NONAMESET);
	    }

	    void assert_game ()
	    {
		if (c.game == GameRef.none)
		    raise error (Error.NOTINGAME);
	    }
		
	    void print_client_score (&Client o) {
		Clients::print_client_score (&c, &o);
	    }

	    void print_client_games (&Client o) {
		Clients::print_client_games (&c, &o);
	    }

	    void print_client (&Client o) {
		Clients::print_client (&c, &o);
	    }

	    void	helo (string username) {
		if (Clients::find (username) != ClientRef.none)
		    raise error (Error.INVALIDNAME);
		c.user.username = username;
		respond ("HELO %s\n", server_id);
		Clients::server_send ("NOTICE USER %s\n", username);
	    }

	    void	who () {
		assert_user ();
		respond ("WHO");
		Clients::iterate (print_client_games);
		respond ("\n");
	    }

	    void	games() {
		assert_user ();
		respond ("GAMES");
		Games::iterate (void func(&Game g) {
		    respond (" %s", g.name);
		});
		respond ("\n");
	    }

	    void	players(string game) {
		assert_user ();
		&Game	g = Games::find (game);
		respond ("PLAYERS");
		Games::iterate_client (&g, print_client_score, true, false);
		respond ("\n");
	    }

	    void	watchers(string game) {
		assert_user ();
		&Game	g = Games::find (game);
		respond ("WATCHERS");
		Games::iterate_client (&g, print_client, false, true);
		respond ("\n");
	    }

	    void	gameinfo (string game) {
		assert_user ();
		&Game	g = Games::find (game);

		int	    turn = 17 - dim (g.targets);
		
		int	    remain = 0;
		if (g.state == GameState.Bidding)
		{
		    remain = g.expire_time - time();
		    if (remain < 0) remain = 0;
		}
		
		int	    bid = 0;
		union switch (Games::lowest_bidder (&g)) {
		case none: break;
		case client c: bid = c.bid.number; break;
		}

		string	    active = "";
		switch (g.state) {
		case GameState.Showing:
		case GameState.Solved:
		    active = g.active.client.user.username;
		    break;
		}

		respond ("GAMEINFO %d %C %S %G %d %d %s\n",
			 turn, 
			 g.target.color,
			 g.target.shape,
			 g.state,
			 remain,
			 bid,
			 active);
	    }

	    void	userinfo (string username) {
		assert_user ();
		ClientRef	cr = Clients::find (username);
		union switch (cr) {
		case none:
		    raise error (Error.NOUSER);
		case client c:
		    string  game = "";
		    bool    playing = false;
		    int	    score = 0;
		    int	    bid = 0;

		    union switch (c.game) {
		    case none:	break;
		    case game g:
			game = g.name;
			playing = c.playing;
			if (playing)
			{
			    score = c.score;
			    if (c.bid != Bid.none)
				bid = c.bid.number;
			}
		    }
		    respond ("USERINFO %s %b %d %d\n",
			     game, playing, score, bid);
		}
	    }
	    
	    void	new(string game) {
		assert_user ();
		&Game g = Games::new (game);
		Games::add_client (&g, &c, true);
		respond ("NEW %s\n", g.name);
	    }

	    void	join (string game) {
		assert_user ();
		&Game g = Games::find (game);
		Games::add_client (&g, &c, true);
		respond ("JOIN\n");
	    }
	    
	    void	watch (string game) {
		assert_user ();
		&Game g = Games::find (game);
		Games::add_client (&g, &c, false);
		respond ("WATCH\n");
	    }
	    
	    void	show () {
		assert_user ();
		assert_game ();
		File::fprintf (f, "SHOW \"\n");
		Show::show (f, &c.game.game.board);
		File::fprintf (f, "\"\n");
	    }

	    void	bid (int number) {
		assert_user ();
		assert_game ();
		Games::bid (&c.game.game, &c, number);
		respond ("BID\n");
	    }

	    void	revoke () {
		assert_user ();
		assert_game ();
		Games::revoke (&c.game.game, &c);
		respond ("REVOKE\n");
	    }

	    void	abandon () {
		assert_user ();
		assert_game ();
		Games::abandon (&c.game.game, &c);
		respond ("ABANDON\n");
	    }

	    void	move (Color color, Direction direction) {
		assert_user ();
		assert_game ();
		Games::move (&c.game.game, &c, color, direction);
		respond ("MOVE %d\n", Games::count (&c.game.game));
	    }

	    void	undo () {
		assert_user ();
		assert_game ();
		Games::undo (&c.game.game, &c);
		respond ("UNDO\n");
	    }

	    void	reset () {
		assert_user ();
		assert_game ();
		Games::reset (&c.game.game, &c);
		respond ("RESET\n");
	    }

	    void	turn () {
		assert_user ();
		assert_game ();
		Games::next_turn (&c.game.game);
		respond ("TURN\n");
	    }

	    void	pass () {
		assert_user ();
		assert_game ();
		Games::pass (&c.game.game, &c);
		respond ("PASS\n");
	    }

	    void	message (string text) {
		assert_user ();
		respond ("MESSAGE\n");
		string u = (c.user == User.none ? "anonymous" :
			    c.user.username);
		Clients::server_send ("NOTICE MESSAGE %s %s\n", u, text);
	    }

	    void	part () {
		assert_user ();
		assert_game ();
		Games::remove_client (&c);
		respond ("PART\n");
	    }
	    
	    void	quit () {
		respond ("QUIT\n");
		raise Readreq::request_closed();
	    }

	    printf ("New client\n");

	    for (;;) {
		try {
		    File::flush (f);
		    Request	r = Readreq::read (f);
		    
		    union switch (r) {
		    case HELO h:    
			helo (h.username);
			break;
		    case WHO:
			who ();
			break;
		    case GAMES:
			games ();
			break;
		    case PLAYERS p:
			players (p.game);
			break;
		    case WATCHERS w:
			watchers (w.game);
			break;
		    case GAMEINFO g:
			gameinfo (g.game);
			break;
		    case USERINFO u:
			userinfo (u.username);
			break;
		    case NEW n:
			new (n.game);
			break;
		    case JOIN j:
			join (j.game);
			break;
		    case WATCH w:
			watch (w.game);
			break;
		    case SHOW:
			show ();
			break;
		    case BID b:
			bid (b.number);
			break;
		    case REVOKE:
			revoke ();
			break;
		    case ABANDON:
			abandon ();
			break;
		    case MOVE m:
			move (m.color, m.direction);
			break;
		    case UNDO:
			undo ();
			break;
		    case RESET:
			reset ();
			break;
		    case TURN:
			turn ();
			break;
		    case PASS:
			pass ();
			break;
		    case MESSAGE m:
			message (m.text);
			break;
		    case PART:
			part ();
			break;
		    case QUIT:
			quit ();
			break;
		    }
		} catch error (Error e) {
		    respond ("ERROR %E\n", e);
		} catch Readreq::request_closed () {
		    return;
		}
	    }
	}

	void client_cleanup (&Client c) {
	    Games::remove_client (&c);
	    Clients::dispose (&c);
	}
	
	public void client (file f)
	{
	    twixt (lock (); unlock ())
		twixt ((&Client c = Clients::new (f)), true;
		       client_cleanup (&c))
		    client_locked (f, &c);
	}
    }
}
