/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload RR
autoload Server
autoload Server::Connect
autoload Server::Readreq
autoload Server::Show

extend namespace Server {
    public namespace Dispatch {
	string	server_id = "RicochetServer";

	public void set_server_id (string id) { server_id = id; }

	public void client (file f) {
	    &Client	c = Connect::new (f);
	    
	    void	helo (string username) {
		c.user.username = username;
		File::fprintf (f, "HELO \"%s\"\n", server_id);
	    }

	    void	who () {
		File::fprintf (f, "WHO");
		Connect::iterate (void func(&Client c) {
		    union switch (c.user) {
		    case none:
			break;
		    case username u:
			File::fprintf (f, " \"%s\"", u);
			break;
		    }
		});
		File::fprintf (f, "\n");
	    }

	    void	show () {
		union switch (c.game) {
		case none:
		    File::fprintf (f, "ERROR NOTINGAME\n");
		    break;
		case game g:
		    File::fprintf (f, "SHOW \"\n");
		    Show::show (f, &g.board);
		    File::fprintf (f, "\"\n");
		    break;
		}
	    }

	    void	quit () {
		File::fprintf (f, "QUIT\n");
		raise Readreq::request_closed();
	    }

	    printf ("New client\n");

	    for (;;) {
		try {
		    File::flush (f);
		    Request	r = Readreq::read (f);
		    union switch (r) {
		    case HELO h:    
			helo (h.username);
			break;
		    case WHO:
			who ();
			break;
		    case SHOW:
			show ();
			break;
		    case QUIT:
			quit ();
			break;
		    default:
			printf ("not done yet %v\n", r);
			break;
		    }
		} catch Readreq::invalid_request (string w) {
		    File::fprintf (f, "ERROR COMMAND %s\n", w);
		} catch Readreq::request_closed () {
		    printf ("Client closed\n");
		    Connect::dispose (&c);
		    File::close (f);
		    return;
		} catch RR::Lex::syntax() {
		    File::fprintf (f, "ERROR SYNTAX\n");
		    RR::Lex::skipline (f);
		} catch RR::Lex::invalid_color (string color) {
		    File::fprintf (f, "ERROR NOTCOLOR %s\n", color);
		    RR::Lex::skipline (f);
		} catch RR::Lex::invalid_shape (string shape) {
		    File::fprintf (f, "ERROR NOTSHAPE %s\n", shape);
		    RR::Lex::skipline (f);
		} catch RR::Lex::invalid_direction (string direction) {
		    File::fprintf (f, "ERROR NOTDIRECTION %s\n", direction);
		    RR::Lex::skipline (f);
		}
	    }
	}
    }
}
