/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload RR
autoload Server
autoload Server::Connect
autoload Server::Readreq
autoload Server::Show
autoload Server::Games

extend namespace Server {
    public namespace Dispatch {
	string	server_id = "RicochetServer";

	public void set_server_id (string id) { server_id = id; }

	public void client (file f) {
	    &Client	c = Connect::new (f);
	    
	    void	helo (string username) {
		c.user.username = username;
		File::fprintf (f, "HELO \"%s\"\n", server_id);
	    }

	    void print_client (&Client c) {
		union switch (c.user) {
		case none:
		    break;
		case username u:
		    File::fprintf (f, " \"%s\"", u);
		    break;
		}
	    }
	    
	    void print_client_score (&Client c) {
		union switch (c.user) {
		case none:
		    break;
		case username u:
		    File::fprintf (f, " \"%s\" %d", u, c.score);
		    break;
		}
	    }
	    
	    void	who () {
		File::fprintf (f, "WHO");
		Connect::iterate (print_client);
		File::fprintf (f, "\n");
	    }

	    void	games() {
		File::fprintf (f, "GAMES");
		Games::iterate (void func(&Game g) {
		    File::fprintf (f, " \"%s\"", g.name);
		});
		File::fprintf (f, "\n");
	    }

	    void	users(string game) {
		try {
		    &Game	g = Games::find (game);
		    File::fprintf (f, "USERS");
		    Games::iterate_client (&g, print_client_score);
		    File::fprintf (f, "\n");
		} catch Games::no_such_game (string name) {
		    File::fprintf (f, "ERROR NOGAME\n");
		}
	    }

	    void	join (string game) {
		try {
		    &Game g = Games::find (game);
		    Games::add_client (&g, &c);
		} catch Games::no_such_game (string game) {
		    File::fprintf (f, "ERROR NOGAME\n");
		}
	    }
	    
	    void	new(string game) {
		&Game g = Games::new (game);
		join (g.name);
		File::fprintf (f, "NEW \"%s\"\n", g.name);
	    }

	    void	show () {
		union switch (c.game) {
		case none:
		    File::fprintf (f, "ERROR NOTINGAME\n");
		    break;
		case game g:
		    File::fprintf (f, "SHOW \"\n");
		    Show::show (f, &g.board);
		    File::fprintf (f, "\"\n");
		    break;
		}
	    }

	    void	bid (int number) {
		File::fprintf (f, "BID\n");
	    }

	    void	move (Color color, Direction direction) {
		union switch (c.game) {
		case none:
		    File::fprintf (f, "ERROR NOTINGAME\n");
		    break;
		case game g:
		    try {
			Games::move (&g, &c, color, direction);
			File::fprintf (f, "MOVE\n");
		    } catch Games::notactive (&Game g, &Client c) {
			File::fprintf (f, "ERROR NOTACTIVE\n");
		    }
		    break;
		}
	    }

	    void	undo () {
		union switch (c.game) {
		case none:
		    File::fprintf (f, "ERROR NOTINGAME\n");
		    break;
		case game g:
		    try {
			Games::undo (&g, &c);
			File::fprintf (f, "UNDO\n");
		    } catch Games::notactive (&Game g, &Client c) {
			File::fprintf (f, "ERROR NOTACTIVE\n");
		    }
		    break;
		}
	    }

	    void	reset () {
		union switch (c.game) {
		case none:
		    File::fprintf (f, "ERROR NOTINGAME\n");
		    break;
		case game g:
		    try {
			Games::reset (&g, &c);
			File::fprintf (f, "RESET\n");
		    } catch Games::notactive (&Game g, &Client c) {
			File::fprintf (f, "ERROR NOTACTIVE\n");
		    }
		    break;
		}
	    }

	    void	turn () {
		union switch (c.game) {
		case none:
		    File::fprintf (f, "ERROR NOTINGAME\n");
		    break;
		case game g:
		    if (Games::solved (&g))
			Games::next_target (&g);
		    File::fprintf (f, "TURN\n");
		    break;
		}
	    }

	    void	pass () {
	    }

	    void	message (string text) {
		File::fprintf (f, "MESSAGE\n");
		Connect::iterate (void func (&Client o) {
		    string u = c.user == User.none ? "anonymous" :
		    c.user.username;
		    File::fprintf (o.f, "NOTICE MESSAGE \"%s\" \"%s\"\n",
				   u, text);
		    File::flush (o.f);
		});
	    }

	    void	quit () {
		File::fprintf (f, "QUIT\n");
		raise Readreq::request_closed();
	    }

	    printf ("New client\n");

	    for (;;) {
		try {
		    File::flush (f);
		    Request	r = Readreq::read (f);
		    union switch (r) {
		    case HELO h:    
			helo (h.username);
			break;
		    case WHO:
			who ();
			break;
		    case GAMES:
			games ();
			break;
		    case USERS u:
			users (u.game);
			break;
		    case NEW n:
			new (n.game);
			break;
		    case JOIN j:
			join (j.game);
			break;
		    case WATCH w:
#			watch (w.game);
			break;
		    case SHOW:
			show ();
			break;
		    case BID b:
			bid (b.number);
			break;
		    case MOVE m:
			move (m.color, m.direction);
			break;
		    case UNDO:
			undo ();
			break;
		    case RESET:
			reset ();
			break;
		    case TURN:
			turn ();
			break;
		    case PASS:
			pass ();
			break;
		    case MESSAGE m:
			message (m.text);
			break;
		    case QUIT:
			quit ();
			break;
		    }
		} catch Readreq::invalid_request (string w) {
		    File::fprintf (f, "ERROR COMMAND %s\n", w);
		} catch Readreq::request_closed () {
		    printf ("Client closed\n");
		    Connect::dispose (&c);
		    File::close (f);
		    return;
		} catch RR::Lex::syntax() {
		    File::fprintf (f, "ERROR SYNTAX\n");
		    RR::Lex::skipline (f);
		} catch RR::Lex::invalid_color (string color) {
		    File::fprintf (f, "ERROR NOTCOLOR %s\n", color);
		    RR::Lex::skipline (f);
		} catch RR::Lex::invalid_shape (string shape) {
		    File::fprintf (f, "ERROR NOTSHAPE %s\n", shape);
		    RR::Lex::skipline (f);
		} catch RR::Lex::invalid_direction (string direction) {
		    File::fprintf (f, "ERROR NOTDIRECTION %s\n", direction);
		    RR::Lex::skipline (f);
		}
	    }
	}
    }
}
