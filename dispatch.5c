/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload RR
autoload RR::Send
autoload Server
autoload Server::Clients
autoload Server::Readreq
autoload Server::Show
autoload Server::Games

extend namespace Server {
    public namespace Dispatch {
	string	server_id = "RicochetServer";

	public void set_server_id (string id) { server_id = id; }

	void client_locked (file f) {
	    &Client	c = Clients::new (f);
	    
	    exception	notactive ();
	    exception	notingame ();
	    exception	invalidname ();
	    exception	nonameset ();

	    void	broadcast (string fmt, poly args...) {
		RR::Send::send (stdout, "broadcast: ");
		RR::Send::send (stdout, fmt, args...);
		void	message_client (&Client o) {
		    if (&o != &c)
		    {
			RR::Send::send (o.f, fmt, args...);
			File::flush (o.f);
		    }
		}
		Clients::iterate (message_client);
		RR::Send::send (stdout, "done\n");
	    }

	    void	respond (string fmt, poly args...) {
		RR::Send::send (stdout, "respond: ");
		RR::Send::send (stdout, fmt, args...);
		RR::Send::send (f, fmt, args...);
	    }

	    void print_client (&Client o) {
		union switch (o.user) {
		case none:
		    break;
		case username u:
		    respond (" %s", u);
		    break;
		}
	    }
	    
	    void print_client_score (&Client c) {
		union switch (c.user) {
		case none:
		    break;
		case username u:
		    respond (" %s %d", u, c.score);
		    break;
		}
	    }
	    
	    void	helo (string username) {
		if (Clients::find (username) != ClientRef.none)
		    raise invalidname ();
		c.user.username = username;
		respond ("HELO %s\n", server_id);
		broadcast ("NOTICE USER %s\n", username);
	    }

	    void	who () {
		respond ("WHO");
		Clients::iterate (print_client);
		respond ("\n");
	    }

	    void	games() {
		respond ("GAMES");
		Games::iterate (void func(&Game g) {
		    respond (" %s", g.name);
		});
		respond ("\n");
	    }

	    void	users(string game) {
		&Game	g = Games::find (game);
		respond ("USERS");
		Games::iterate_client (&g, print_client_score);
		respond ("\n");
	    }

	    void	join (string game) {
		&Game g = Games::find (game);
		Games::add_client (&g, &c);
		respond ("JOIN\n");
		broadcast ("NOTICE JOIN %s %s\n", g.name, c.user.username);
	    }
	    
	    void	new(string game) {
		&Game g =Games::new (game);
		Games::add_client (&g, &c);
		respond ("NEW %s\n", g.name);
		broadcast ("NOTICE NEW %s\n", g.name);
	    }

	    void	show () {
		union switch (c.game) {
		case none:
		    raise notingame ();
		    break;
		case game g:
		    File::fprintf (f, "SHOW \"\n");
		    Show::show (f, &g.board);
		    File::fprintf (f, "\"\n");
		    break;
		}
	    }

	    void	bid (int number) {
		respond ("BID\n");
		broadcast ("BID %s %d\n", c.user.username, number);
	    }

	    void	move (Color color, Direction direction) {
		union switch (c.game) {
		case none:
		    raise notingame ();
		case game g:
		    Games::move (&g, &c, color, direction);
		    respond ("MOVE\n");
		    break;
		}
		broadcast ("NOTICE MOVE %C %D\n", color, direction);
	    }

	    void	undo () {
		union switch (c.game) {
		case none:
		    raise notingame ();
		    break;
		case game g:
		    Games::undo (&g, &c);
		    respond ("UNDO\n");
		    break;
		}
		broadcast ("NOTICE UNDO\n");
	    }

	    void	reset () {
		union switch (c.game) {
		case none:
		    raise notingame ();
		    break;
		case game g:
		    Games::reset (&g, &c);
		    respond ("RESET\n");
		    break;
		}
		broadcast ("NOTICE RESET\n");
	    }

	    void	turn () {
		union switch (c.game) {
		case none:
		    raise notingame ();
		case game g:
		    if (Games::solved (&g))
			Games::next_turn (&g);
		    respond ("TURN\n");
		    break;
		}
		broadcast ("NOTICE TURN\n");
	    }

	    void	pass () {
	    }

	    void	message (string text) {
		respond ("MESSAGE\n");
		string u = (c.user == User.none ? "anonymous" :
			    c.user.username);
		broadcast ("NOTICE MESSAGE %s %s\n", u, text);
	    }

	    void	quit () {
		respond ("QUIT\n");
		raise Readreq::request_closed();
	    }

	    printf ("New client\n");

	    for (;;) {
		try {
		    File::flush (f);
		    Request	r = Readreq::read (f);
		    union switch (r) {
		    case HELO:
		    case QUIT:
			 break;
		    default:
			if (c.user == User.none)
			    raise nonameset ();
			break;
		    }
		    union switch (r) {
		    case HELO h:    
			helo (h.username);
			break;
		    case WHO:
			who ();
			break;
		    case GAMES:
			games ();
			break;
		    case USERS u:
			users (u.game);
			break;
		    case NEW n:
			new (n.game);
			break;
		    case JOIN j:
			join (j.game);
			break;
		    case WATCH w:
#			watch (w.game);
			break;
		    case SHOW:
			show ();
			break;
		    case BID b:
			bid (b.number);
			break;
		    case MOVE m:
			move (m.color, m.direction);
			break;
		    case UNDO:
			undo ();
			break;
		    case RESET:
			reset ();
			break;
		    case TURN:
			turn ();
			break;
		    case PASS:
			pass ();
			break;
		    case MESSAGE m:
			message (m.text);
			break;
		    case QUIT:
			quit ();
			break;
		    }
		} catch Readreq::invalid_request (string w) {
		    respond ("ERROR COMMAND %s\n", w);
		} catch RR::Lex::syntax() {
		    respond ("ERROR SYNTAX\n");
		} catch RR::Lex::invalid_color (string color) {
		    respond ("ERROR NOTCOLOR %s\n", color);
		} catch RR::Lex::invalid_shape (string shape) {
		    respond ("ERROR NOTSHAPE %s\n", shape);
		} catch RR::Lex::invalid_direction (string direction) {
		    respond ("ERROR NOTDIRECTION %s\n", direction);
		} catch Games::notactive (&Game g, &Client c) {
		    respond ("ERROR NOTACTIVE\n");
		} catch notingame () {
		    respond ("ERROR NOTINGAME\n");
		} catch Games::no_such_game (string name) {
		    respond ("ERROR NOGAME\n");
		} catch nonameset () {
		    respond ("ERROR NONAMESET\n");
		} catch invalidname () {
		    respond ("ERROR INVALIDNAME\n");
		} catch Readreq::request_closed () {
		    User user = c.user;
		    printf ("Client closed %v\n", c.user);
		    Clients::dispose (&c);
		    File::close (f);
		    if (c.user != User.none)
			broadcast ("NOTICE PART %s\n", c.user.username);
		    return;
		}
	    }
	}

	public void client (file f)
	{
	    twixt (lock (); unlock ())
		client_locked (f);
	}
    }
}
