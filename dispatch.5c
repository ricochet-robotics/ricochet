/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload RR
autoload RR::Send
autoload Server
autoload Server::Clients
autoload Server::Readreq
autoload Server::Show
autoload Server::Games

extend namespace Server {
    public namespace Dispatch {
	
	void client_locked (file f, &Client c) {
	    
	    exception	notactive ();
	    exception	notingame ();
	    exception	invalidname ();
	    exception	nonameset ();

	    void	respond (string fmt, poly args...) {
		Clients::client_send (&c, fmt, args...);
	    }

	    void print_client (&Client o) {
		union switch (o.user) {
		case none:
		    break;
		case username u:
		    respond (" %s", u);
		    break;
		}
	    }
	    
	    void print_client_score (&Client c) {
		union switch (c.user) {
		case none:
		    break;
		case username u:
		    respond (" %s %d", u, c.score);
		    break;
		}
	    }
	    
	    void assert_user ()
	    {
		if (c.user == User.none)
		    raise nonameset ();
	    }

	    void assert_game ()
	    {
		if (c.game == GameRef.none)
		    raise notingame ();
	    }
		
	    void	helo (string username) {
		if (Clients::find (username) != ClientRef.none)
		    raise invalidname ();
		c.user.username = username;
		respond ("HELO %s\n", server_id);
		Clients::server_send ("NOTICE USER %s\n", username);
	    }

	    void	who () {
		assert_user ();
		respond ("WHO");
		Clients::iterate (print_client);
		respond ("\n");
	    }

	    void	games() {
		assert_user ();
		respond ("GAMES");
		Games::iterate (void func(&Game g) {
		    respond (" %s", g.name);
		});
		respond ("\n");
	    }

	    void	users(string game) {
		assert_user ();
		&Game	g = Games::find (game);
		respond ("USERS");
		Games::iterate_client (&g, print_client_score);
		respond ("\n");
	    }

	    void	join (string game) {
		assert_user ();
		&Game g = Games::find (game);
		Games::add_client (&g, &c, true);
		respond ("JOIN\n");
	    }
	    
	    void	new(string game) {
		assert_user ();
		&Game g =Games::new (game);
		Games::add_client (&g, &c, false);
		respond ("NEW %s\n", g.name);
		Clients::server_send ("NOTICE NEW %s\n", g.name);
	    }

	    void	show () {
		assert_user ();
		assert_game ();
		File::fprintf (f, "SHOW \"\n");
		Show::show (f, &c.game.game.board);
		File::fprintf (f, "\"\n");
	    }

	    void	bid (int number) {
		assert_user ();
		assert_game ();
		Games::bid (&c.game.game, &c, number);
		respond ("BID\n");
	    }

	    void	move (Color color, Direction direction) {
		assert_user ();
		assert_game ();
		Games::move (&c.game.game, &c, color, direction);
		respond ("MOVE %d\n", Games::count (&c.game.game));
	    }

	    void	undo () {
		assert_user ();
		assert_game ();
		Games::undo (&c.game.game, &c);
		respond ("UNDO\n");
	    }

	    void	reset () {
		assert_user ();
		assert_game ();
		Games::reset (&c.game.game, &c);
		respond ("RESET\n");
	    }

	    void	turn () {
		assert_user ();
		assert_game ();
		if (Games::solved (&c.game.game))
		    Games::next_turn (&c.game.game);
		respond ("TURN\n");
	    }

	    void	pass () {
		assert_user ();
		assert_game ();
	    }

	    void	message (string text) {
		assert_user ();
		respond ("MESSAGE\n");
		string u = (c.user == User.none ? "anonymous" :
			    c.user.username);
		Clients::server_send ("NOTICE MESSAGE %s %s\n", u, text);
	    }

	    void	quit () {
		respond ("QUIT\n");
		raise Readreq::request_closed();
	    }

	    printf ("New client\n");

	    for (;;) {
		try {
		    File::flush (f);
		    Request	r = Readreq::read (f);
		    
		    union switch (r) {
		    case HELO h:    
			helo (h.username);
			break;
		    case WHO:
			who ();
			break;
		    case GAMES:
			games ();
			break;
		    case USERS u:
			users (u.game);
			break;
		    case NEW n:
			new (n.game);
			break;
		    case JOIN j:
			join (j.game);
			break;
		    case WATCH w:
#			watch (w.game);
			break;
		    case SHOW:
			show ();
			break;
		    case BID b:
			bid (b.number);
			break;
		    case MOVE m:
			move (m.color, m.direction);
			break;
		    case UNDO:
			undo ();
			break;
		    case RESET:
			reset ();
			break;
		    case TURN:
			turn ();
			break;
		    case PASS:
			pass ();
			break;
		    case MESSAGE m:
			message (m.text);
			break;
		    case QUIT:
			quit ();
			break;
		    }
		} catch Readreq::invalid_request (string w) {
		    respond ("ERROR COMMAND %s\n", w);
		} catch RR::Lex::syntax() {
		    respond ("ERROR SYNTAX\n");
		} catch RR::Lex::invalid_color (string color) {
		    respond ("ERROR NOTCOLOR %s\n", color);
		} catch RR::Lex::invalid_shape (string shape) {
		    respond ("ERROR NOTSHAPE %s\n", shape);
		} catch RR::Lex::invalid_direction (string direction) {
		    respond ("ERROR NOTDIRECTION %s\n", direction);
		} catch Games::notactive (&Game g, &Client c) {
		    respond ("ERROR NOTACTIVE\n");
		} catch notingame () {
		    respond ("ERROR NOTINGAME\n");
		} catch Games::no_such_game (string name) {
		    respond ("ERROR NOGAME\n");
		} catch nonameset () {
		    respond ("ERROR NONAMESET\n");
		} catch invalidname () {
		    respond ("ERROR INVALIDNAME\n");
		} catch Games::notbidding (&Game g) {
		    respond ("ERROR NOTBIDDING\n");
		} catch Games::toomanymoves (&Game g, &Client c) {
		    respond ("ERROR TOOMANYMOVES\n");
		} catch Games::blocked (&Game g, &Client c) {
		    respond ("ERROR BLOCKED\n");
		} catch Games::notlower (&Game g, &Client c, int bid) {
		    respond ("ERROR NOTLOWER\n");
		} catch Readreq::request_closed () {
		    User user = c.user;
		    printf ("Client closed %v\n", c.user);
		    Clients::dispose (&c);
		    if (c.user != User.none)
			Clients::server_send ("NOTICE PART %s\n", c.user.username);
		    return;
		}
	    }
	}

	void client_cleanup (&Client c) {
	    if (c.game != GameRef.none)
		Games::remove_client (&c.game.game, &c);
	    Clients::dispose (&c);
	}
	
	public void client (file f)
	{
    	    twixt (true; File::close (f))
		twixt (lock (); unlock ())
		    twixt ((&Client c = Clients::new (f)), true;
			   client_cleanup (&c))
			client_locked (f, &c);
	}
    }
}
