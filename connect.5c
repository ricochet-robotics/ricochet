/*
 * $Id$
 *
 * Copyright Â© 2003 Keith Packard
 *
 * Permission to use, copy, modify, distribute, and sell this software and its
 * documentation for any purpose is hereby granted without fee, provided that
 * the above copyright notice appear in all copies and that both that
 * copyright notice and this permission notice appear in supporting
 * documentation, and that the name of Keith Packard not be used in
 * advertising or publicity pertaining to distribution of the software without
 * specific, written prior permission.  Keith Packard makes no
 * representations about the suitability of this software for any purpose.  It
 * is provided "as is" without express or implied warranty.
 *
 * KEITH PACKARD DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL KEITH PACKARD BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
 * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

autoload Server

extend namespace Server {
    public namespace Connect {
	(&Client)[0]    clients = {};

	public void iterate (void (&Client c) f) {
	    for (int i = 0; i < dim (clients); i++)
		f (&clients[i]);
	}

	public exception no_such_client (file f);

	public &Client select (file f) {
	    exception found (&Client c);
	    try {
		void pick (&Client c) {
		    if (c.f == f)
			raise found (&c);
		}
		iterate (pick);
	    } catch found (&Client c) {
		return &c;
	    }
	    raise no_such_client (f);
	}

	public &Client new (file f) {
	    clients = ((&Client)[dim(clients)+1]) { 
		[i] = i < dim(clients) ? 
		&clients[i] : 
		reference ((Client) { 
		    f = f, 
		    user = User.none, 
		    game = GameRef.none 
		})
	    };
	    return &clients[dim(clients)-1];
	}

	public void dispose (&Client c) {
	    bool found = false;

	    clients = ((&Client)[dim(clients)-1]) { 
		[i] = found ? &clients[i+1] : (&clients[i] == &c ? 
					      (found=true, &clients[i+1]) :
					      &clients[i])
	    };
	}

	public void print (&Client c) {
	    printf ("%v\n", c);
	}
    }
}
